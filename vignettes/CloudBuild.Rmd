---
title: "Serverless R via Cloud Build"
---

Cloud Build uses containers to run everything.  This means it can run almost any language/program or application including R. Having an easy way to create and trigger these builds from R means R can serve as a UI or gateway to any other program e.g. R can trigger a Cloud Build using `gcloud` to deploy Cloud Run applications.

The first 120 mins per day are free.  [See here for more priceinfo.](https://cloud.google.com/cloud-build/pricing)

Cloud Run is an alternative if you want a URL endpoint for your script. If you want to run scripts that can be triggered one time, setup to trigger on GitHub events or pub/sub, or scheduled using Cloud Scheduler then Cloud Build is more suited to that use case. 

## cloudbuild.yaml

Cloud Build is centered around the [cloudbuild.yaml format](https://cloud.google.com/cloud-build/docs/build-config) - you can use existing cloudbuild.yaml files or create your own in R using the yaml helper functions.

An example cloudbuild.yaml is shown below - this outputs the versions of docker and echos "Hello Cloud Build":

```yaml
steps:
- name: 'gcr.io/cloud-builders/docker'
  id: Docker Version
  args: ["version"]
- name: 'alpine'
  id:  Hello Cloud Build
  args: ["echo", "Hello Cloud Build"]
```

This cloudbuild.yaml file can be built directly via the `cr_build()` function:

```r
b1 <- cr_build("cloudbuild.yaml")
```
The build will trigger an RStudio Jobs if you are using RStudio, or a webpage for the build logs to open.  Or you can choose to wait in R for the build to finish, like below:

```r
b2 <- cr_build("cloudbuild.yaml", launch_browser = FALSE)
cr_build_wait(b2)
# Waiting for build to finish:
#  |===||
# Build finished
# ==CloudBuildObject==
# buildId:  c673143a-794d-4c69-8ad4-e777d068c066 
# status:  SUCCESS 
# logUrl:  https://console.cloud.google.com/gcr/builds/c673143a-794d-4c69-8ad4-e777d068c066?project=1080525199262 
# steps: 
#  name:
# - gcr.io/cloud-builders/docker
# - alpine
# args:
# - version
# - - echo
#   - Hello Cloud Build
# id:
# - Docker Version
# - Hello Cloud Build
# timing:
#   startTime:
#   - '2019-11-12T11:16:37.682826707Z'
#   - '2019-11-12T11:16:38.585221812Z'
#   endTime:
#   - '2019-11-12T11:16:38.585157179Z'
#   - '2019-11-12T11:16:40.680755419Z'
# status:
# - SUCCESS
# - SUCCESS
# pullTiming:
#   startTime:
#   - '2019-11-12T11:16:37.682826707Z'
#   - '2019-11-12T11:16:38.585221812Z'
#   endTime:
#   - '2019-11-12T11:16:37.740729198Z'
#   - '2019-11-12T11:16:39.869607125Z'
```

You can also reuse Cloud Build objects to re-run the same build.  This is helpful when you test a build works locally, then pass the result of a successful run to `cr_build_schedule_http()` to schedule it. 

```r
# a cloud build you would like to schedule
itworks <- cr_build("cloudbuild.yaml", launch_browser = FALSE)

# once working, pass in the build to the scheduler
cr_schedule("15 5 * * *", name="itworks-schedule",
            httpTarget = cr_build_schedule_http(itworks))
```



## Cloud Build source

Cloud Builds usually need code or data to work on to be useful.  This is specified by the `source` argument.  

This can be a Cloud Source Repository (perhaps mirrored from GitHub) or a Cloud Storage bucket containg the code/data you want to operate on.  An example of specifying both is below:

```r
gcs_source <- Source(
  storageSource=StorageSource("gs://my-bucket", "my_code.tar.gz"))
  
repo_source <- Source(
  repoSource=RepoSource("github_markedmondson1234_googlecloudrunner",
                        branchName="master"))

build1 <- cr_build("cloudbuild.yaml", source = gcs_source)
build2 <- cr_build("cloudbuild.yaml", source = repo_source)
```

You can also turn an existing build into a cloudbuild.yaml file:

```r
cr_build_write(build1)
```

There is a helper function for automating creation of a Google Cloud Storage source called `cr_build_upload_gcs()`

This returns a `Source` object that can be used in build functions:

```
storage <- cr_build_upload_gcs("my_folder")
```

## Cloud Build macros

Cloud Builds can use reserved macros and variables to help with deployments in a continuous development situation.  For instance, files can be named according to the Git branch they are committed from.  These are listed in `?Build` and reproduced below:

* $PROJECT_ID: the project ID of the build.
* $BUILD_ID: the autogenerated ID of the build.
* $REPO_NAME: the source repository name specified by RepoSource.
* $BRANCH_NAME: the branch name specified by RepoSource.
* $TAG_NAME: the tag name specified by RepoSource.
* $REVISION_ID or $COMMIT_SHA: the commit SHA specified by RepoSource or resolved from the specified branch or tag.
* $SHORT_SHA: first 7 characters of $REVISION_ID or $COMMIT_SHA.

Custom macros can also be configured in the web UI, starting with _$ e.g. _$MY_CUSTOM_MACRO

## Program cloudbuild.yaml objects via Yaml()

Lets say you don't want to write a cloudbuild.yaml file - instead its created all within R using the yaml helper functions `Yaml()` and `cr_buildstep`.  Refer to the [cloudbuild.yaml config spec](https://cloud.google.com/cloud-build/docs/build-config) on what it expected in the file. 

```r
image <- "gcr.io/your-project/your-name"
my_yaml <- Yaml(
      steps = cr_buildstep(
                  "my-r-script",
                  "R -e run.R",
                  prefix = "gcr.io/my-r-images/"
                ))
my_yaml
#==cloudRunnerYaml==
#steps:
#- name: gcr.io/my-r-images/my-r-script
#  args: R -e run.R
#  dir: deploy
```

You can also write out the yaml into your own cloudbuild.yaml

```r
cr_build_write(my_yaml, file = "cloudbuild.yaml")
```

This allows you to programmatically create cloudbuild yaml files for other languages and triggers.

Some helpful build yamls are included:

* `cr_buildstep_docker()` - for building and pushing Docker images
* `cr_buildstep_decrypt()` - for using Google Key management store to decrypt auth files

Combine buildsteps with `c()` e.g.

```r
my_yaml <- Yaml(
      steps = c(cr_buildstep_docker(
                  "my-image", tag="dev"
                ),
                cr_buildstep_decrypt(
                  "secret","auth.json","keyring","key"
                ),
                cr_buildstep(
                  "my-r-script",
                  "R -e run.R",
                  prefix = "gcr.io/my-r-images/"
                ),
      images = "gcr.io/my-r-images/my-image"))
```

The code/source of the build also usually needs to be included.  This can be a Cloud Repository mirrored from GitHub, but here we will upload it to a folder on your own private Google Cloud Storage bucket via the helper `cr_build_upload_gcs()`

This returns a `Source` object that can be used in build functions:

```r
storage <- cr_build_upload_gcs("my_folder")
```

Putting the above together:

```r
cr_build(my_yaml, source = storage)
```
