---
title: "Serverless batched R scripts via Cloud Build"
---

Cloud Build uses [Docker containers](https://www.docker.com/resources/what-container) to run everything.  This means it can run almost any language/program or application including R. Having an easy way to create and trigger these builds from R means R can serve as a UI or gateway to any other program e.g. R can trigger a Cloud Build using `gcloud` to deploy Cloud Run applications.

The first 120 mins per day are free.  [See here for more priceinfo.](https://cloud.google.com/cloud-build/pricing)

If you want to run scripts that can be triggered one time, batch style, and set them up to trigger on GitHub events or pub/sub, or schedule them using Cloud Scheduler then Cloud Build is suited to your use case. 

If you would also like to have your R code react in realtime to events such as HTTP or sub/sub events, such as a website or API endpoint, consider [Cloud Run](https://code.markedmondson.me/googleCloudRunner/articles/cloudrun.html). 

## cloudbuild.yaml

Cloud Build is centered around the [cloudbuild.yaml format](https://cloud.google.com/cloud-build/docs/build-config) - you can use existing cloudbuild.yaml files or create your own in R using the cloudbuild.yaml helper functions.

An example cloudbuild.yaml is shown below - this outputs the versions of docker and echos "Hello Cloud Build" and calls an R function:

```yaml
steps:
- name: 'gcr.io/cloud-builders/docker'
  id: Docker Version
  args: ["version"]
- name: 'alpine'
  id:  Hello Cloud Build
  args: ["echo", "Hello Cloud Build"]
- name: 'rocker/r-base'
  id: Hello R
  args: ["R", "-e", "paste0('1 + 1 = ', 1+1)"]

```

This cloudbuild.yaml file can be built online directly via the `cr_build()` function:

```r
b1 <- cr_build("cloudbuild.yaml")
```

The build will trigger an RStudio Jobs if you are using RStudio, or a webpage for the build logs to open.  Or you can choose to wait in R for the build to finish, like below:

```r
b2 <- cr_build("cloudbuild.yaml", launch_browser = FALSE)
b3 <- cr_build_wait(b2)
# Waiting for build to finish:
#  |===||
# Build finished
# ==CloudBuildObject==
# buildId:  c673143a-794d-4c69-8ad4-e777d068c066 
# status:  SUCCESS 
# logUrl:  https://console.cloud.google.com/gcr/builds/c673143a-794d-4c69-8ad4-e777d068c066?project=1080525199262 
# ...
```

You can turn an existing build into a cloudbuild.yaml file, for instance to run in another project not using R. 

```r
cr_build_write(b3, file = "cloudbuild.yml")
```

You can also reuse Cloud Build objects to re-run a new build with the same settings.  This is helpful when you test a build works locally, then pass the result of a successful run to `cr_build_schedule_http()` to schedule it. 

```r
# a cloud build you would like to schedule
itworks <- cr_build("cloudbuild.yaml", launch_browser = FALSE)

# once working, pass in the build to the scheduler
cr_schedule("15 5 * * *", name="itworks-schedule",
            httpTarget = cr_build_schedule_http(itworks))
```

## Cloud Build source

Cloud Builds sometimes need code or data to work on to be useful.  

All cloudbuilds are launched in a serverless environment with a default directory `/workspace/`.  The Source is copied into this workspace before the build steps execute, so steps can share state and files. 

Cloud Build sources are specified by the `source` argument.

A source can be a [Cloud Source Repository](https://cloud.google.com/source-repositories/) (perhaps mirrored from GitHub) or a [Cloud Storage](https://cloud.google.com/storage/) bucket containg the code/data you want to operate on.  An example of specifying both is below:

```r
gcs_source <- cr_build_source("gs://my-bucket", "my_code.tar.gz")
  
repo_source <- cr_build_source(
  RepoSource("github_markedmondson1234_googlecloudrunner",
             branchName="master"))

build1 <- cr_build("cloudbuild.yaml", source = gcs_source)
build2 <- cr_build("cloudbuild.yaml", source = repo_source)
```

There is a helper function for automating creation of a Google Cloud Storage source called `cr_build_upload_gcs()` - this uses [`googleCloudStorageR`](http://code.markedmondson.me/googleCloudStorageR/)
 to tar and upload your source code locally to your bucket, making it available to your build.
 
This returns a `Source` object that can be used in build functions:

```
storage <- cr_build_upload_gcs("my_folder")
```

## Cloud Build macros

Cloud Builds can use reserved macros and variables to help with deployments in a continuous development situation.  For instance, files can be named according to the Git branch they are committed from.  These are listed in `?Build` and reproduced below:

* $PROJECT_ID: the project ID of the build.
* $BUILD_ID: the autogenerated ID of the build.
* $REPO_NAME: the source repository name specified by RepoSource.
* $BRANCH_NAME: the branch name specified by RepoSource.
* $TAG_NAME: the tag name specified by RepoSource.
* $REVISION_ID or $COMMIT_SHA: the commit SHA specified by RepoSource or resolved from the specified branch or tag.
* $SHORT_SHA: first 7 characters of $REVISION_ID or $COMMIT_SHA.

Custom macros can also be configured in the web UI, starting with _$ e.g. $_MY_CUSTOM_MACRO

## Create cloudbuild.yaml build steps via cr_build_yaml() and cr_buildstep()

Lets say you don't want to write a cloudbuild.yaml file - instead its created all within R using the yaml helper functions `cr_build_yaml()` and `cr_buildstep`.  Refer to the [cloudbuild.yaml config spec](https://cloud.google.com/cloud-build/docs/build-config) on what it expected in the file. 

```r
cr_build_yaml(steps = cr_buildstep( "gcloud","version"))
#==cloudRunnerYaml==
#steps:
#- name: gcr.io/cloud-builders/gcloud
#  args: version
```

You can also write out the yaml into your own cloudbuild.yaml

```r
my_yaml <- cr_build_yaml(steps = cr_buildstep( "gcloud","version"))
cr_build_write(my_yaml, file = "cloudbuild.yaml")
```

This allows you to programmatically create cloudbuild yaml files for other languages and triggers.  See more at this article on [creating custom build steps with your own Docker images](https://cloud.google.com/cloud-build/docs/create-custom-build-steps).

### Pre-made Build Step templates

Some helpful build steps you can use in your own cloudbuild steps are included:

* `cr_buildstep_docker()` - for building and pushing Docker images
* `cr_buildstep_decrypt()` - for using Google Key management store to decrypt auth files
* `cr_buildstep_r()` - for running R code
* `cr_buildstep_git()` - for running git commands
* `cr_buildstep_pkgdown()` - for setting up pkgdown documentation of an R package

Combine buildsteps with `c()` e.g.

```r
cr_build_yaml(
      steps = c(
        cr_buildstep("gcloud","version"),
        cr_buildstep_docker("my-image", tag="dev"),
        cr_buildstep_decrypt("secret","auth.json","keyring","key"),
        cr_buildstep_r("sessionInfo()")),
      images = "gcr.io/my-project/my-image")
```

Before building this example, the code/source of the build will be included.  Here we will upload it to a folder on your own private Google Cloud Storage bucket via the helper `cr_build_upload_gcs()`

This returns a `Source` object that can be used in build functions:

```r
storage <- cr_build_upload_gcs("my_folder")
cr_build(my_yaml, source = storage)
```

### R buildsteps

You can send in R code into a build trigger using `cr_buildstep_r()`.   It accepts both inline R code or a file location.  They default to the R images provided by Rocker [rocker-project.org](https://www.rocker-project.org/) or if you create your own R images you can reference those. 

The R code can be created within the Build at build time, or you can refer to an existing R script within the Source.

```r
# create an R buildstep inline
cr_buildstep_r(c("paste('1+1=', 1+1)", "sessionInfo()"))

# create an R buildstep from a local file
cr_buildstep_r("my-r-file.R")

# create an R buildstep from a file within the source of the Build
cr_buildstep_r("inst/schedule/schedule.R", r_source = "runtime")

# use a different Rocker image e.g. rocker/verse
cr_buildstep_r(c("library(dplyr)", "mtcars %>% select(mpg)", "sessionInfo"),
                name = "verse")

# use your own R image with custom R
my_r <- c("devtools::install()", "pkgdown::build_site()")
br <-  cr_buildstep_r(my_r, name= "gcr.io/gcer-public/packagetools:master")

# send it for building
cr_build(Yaml(steps=br))

```


## Build Triggers

Once you have build steps and possibly a source created, you can either set these up to run on a schedule via `cr_schedule()` or you can use triggers that will run upon certain events.  These include GitHub commits and pull requests.  These Build Triggers can be setup in the webUI or programatically from R via the `cr_buildtrigger()` functions.

To work with GitHub events, configure GitHub to use the offical [Google Cloud Build app](https://github.com/marketplace/google-cloud-build) and then construct your GitHub triggers using `GitHubEventsConfig()`.

The example below shows how to set up some of the builds above:

```r
cloudbuild <- system.file("cloudbuild/cloudbuild.yaml",
                            package = "googleCloudRunner")
bb <- cr_build_make(cloudbuild, projectId = "test-project")
github <- GitHubEventsConfig("MarkEdmondson1234/googleCloudRunner", branch = "master")

cr_buildtrigger("trig1", trigger = github, build = bb)
```

The Build macros can also be configured by passing in a named list:

```r
# creates a trigger with named substitutions
ss <- list(`$_MYVAR` = "TEST1", `$_GITHUB` = "MarkEdmondson1234/googleCloudRunner")
cr_buildtrigger("trig2", trigger = github, build = bb, substitutions = ss)
```

The above examples created the build step inline within the trigger, but you can use existing cloudbuild.yaml files by specifying where in the repository the build file will be:

```r
# create a trigger that will build from the file in the repo
cr_buildtrigger("trig3", trigger = github, build = "inst/cloudbuild/cloudbuild.yaml")
```

