---
title: "Serverless R via Cloud Build"
---

Cloud Build uses containers to run everything.  This means it can run almost any language/program or application including R. Having an easy way to create and trigger these builds from R means R can serve as a UI or gateway to any other program e.g. R can trigger a Cloud Build using `gcloud` to deploy Cloud Run applications.

The first 120 mins per day are free.  [See here for more priceinfo.](https://cloud.google.com/cloud-build/pricing)

Cloud Run is an alternative if you want a URL endpoint for your script. If you want to run scripts that can be triggered one time, setup to trigger on GitHub events or pub/sub, or scheduled using Cloud Scheduler then Cloud Build is more suited to that use case. 

## cloudbuild.yaml

Cloud Build is centered around the [cloudbuild.yaml format](https://cloud.google.com/cloud-build/docs/build-config) - you can use existing cloudbuild.yaml files or create your own in R using the yaml helper functions.

An example cloudbuild.yaml is shown below - this outputs the versions of docker and echos "Hello Cloud Build" and calls an R function:

```yaml
steps:
- name: 'gcr.io/cloud-builders/docker'
  id: Docker Version
  args: ["version"]
- name: 'alpine'
  id:  Hello Cloud Build
  args: ["echo", "Hello Cloud Build"]
- name: 'rocker/r-base'
  id: Hello R
  args: ["R", "-e", "paste0('1 + 1 = ', 1+1)"]

```

This cloudbuild.yaml file can be built directly via the `cr_build()` function:

```r
b1 <- cr_build("cloudbuild.yaml")
```
The build will trigger an RStudio Jobs if you are using RStudio, or a webpage for the build logs to open.  Or you can choose to wait in R for the build to finish, like below:

```r
b2 <- cr_build("cloudbuild.yaml", launch_browser = FALSE)
cr_build_wait(b2)
# Waiting for build to finish:
#  |===||
# Build finished
# ==CloudBuildObject==
# buildId:  c673143a-794d-4c69-8ad4-e777d068c066 
# status:  SUCCESS 
# logUrl:  https://console.cloud.google.com/gcr/builds/c673143a-794d-4c69-8ad4-e777d068c066?project=1080525199262 
# ...
```

You can also reuse Cloud Build objects to re-run the same build.  This is helpful when you test a build works locally, then pass the result of a successful run to `cr_build_schedule_http()` to schedule it. 

```r
# a cloud build you would like to schedule
itworks <- cr_build("cloudbuild.yaml", launch_browser = FALSE)

# once working, pass in the build to the scheduler
cr_schedule("15 5 * * *", name="itworks-schedule",
            httpTarget = cr_build_schedule_http(itworks))
```

## Cloud Build source

Cloud Builds usually need code or data to work on to be useful.  This is specified by the `source` argument.  

This can be a Cloud Source Repository (perhaps mirrored from GitHub) or a Cloud Storage bucket containg the code/data you want to operate on.  An example of specifying both is below:

```r
gcs_source <- cr_build_source("gs://my-bucket", "my_code.tar.gz")
  
repo_source <- cr_build_source(
  RepoSource("github_markedmondson1234_googlecloudrunner",
             branchName="master"))

build1 <- cr_build("cloudbuild.yaml", source = gcs_source)
build2 <- cr_build("cloudbuild.yaml", source = repo_source)
```

You can also turn an existing build into a cloudbuild.yaml file:

```r
cr_build_write(build1)
```

There is a helper function for automating creation of a Google Cloud Storage source called `cr_build_upload_gcs()`

This returns a `Source` object that can be used in build functions:

```
storage <- cr_build_upload_gcs("my_folder")
```

## Cloud Build macros

Cloud Builds can use reserved macros and variables to help with deployments in a continuous development situation.  For instance, files can be named according to the Git branch they are committed from.  These are listed in `?Build` and reproduced below:

* $PROJECT_ID: the project ID of the build.
* $BUILD_ID: the autogenerated ID of the build.
* $REPO_NAME: the source repository name specified by RepoSource.
* $BRANCH_NAME: the branch name specified by RepoSource.
* $TAG_NAME: the tag name specified by RepoSource.
* $REVISION_ID or $COMMIT_SHA: the commit SHA specified by RepoSource or resolved from the specified branch or tag.
* $SHORT_SHA: first 7 characters of $REVISION_ID or $COMMIT_SHA.

Custom macros can also be configured in the web UI, starting with _$ e.g. _$MY_CUSTOM_MACRO

## Create cloudbuild.yaml build steps via Yaml() and cr_buildstep()

Lets say you don't want to write a cloudbuild.yaml file - instead its created all within R using the yaml helper functions `Yaml()` and `cr_buildstep`.  Refer to the [cloudbuild.yaml config spec](https://cloud.google.com/cloud-build/docs/build-config) on what it expected in the file. 

```r
image <- "gcr.io/your-project/your-name"
my_yaml <- Yaml(
      steps = cr_buildstep(
                  "my-r-script",
                  "R -e run.R",
                  prefix = "gcr.io/my-r-images/"
                ))
my_yaml
#==cloudRunnerYaml==
#steps:
#- name: gcr.io/my-r-images/my-r-script
#  args: R -e run.R
#  dir: deploy
```

You can also write out the yaml into your own cloudbuild.yaml

```r
cr_build_write(my_yaml, file = "cloudbuild.yaml")
```

This allows you to programmatically create cloudbuild yaml files for other languages and triggers.  See more at this article on [creating custom build steps with your own Docker images](https://cloud.google.com/cloud-build/docs/create-custom-build-steps).

### Pre-made Build Step templates

Some helpful build yamls are included:

* `cr_buildstep_docker()` - for building and pushing Docker images
* `cr_buildstep_decrypt()` - for using Google Key management store to decrypt auth files
* `cr_buildstep_r()` - for running R code
* `cr_buildstep_git()` - for running git commands
* `cr_buildstep_pkgdown()` - for setting up pkgdown documentation of an R package

Combine buildsteps with `c()` e.g.

```r
my_yaml <- Yaml(
      steps = c(cr_buildstep_docker(
                  "my-image", tag="dev"
                ),
                cr_buildstep_decrypt(
                  "secret","auth.json","keyring","key"
                ),
                cr_buildstep(
                  "my-r-script",
                  c("Rscript","-e", "run.R"),
                  prefix = "gcr.io/my-r-images/"
                ),
      images = "gcr.io/my-r-images/my-image"))
```

The code/source of the build also usually needs to be included.  This can be a Cloud Repository mirrored from GitHub, but here we will upload it to a folder on your own private Google Cloud Storage bucket via the helper `cr_build_upload_gcs()`

This returns a `Source` object that can be used in build functions:

```r
storage <- cr_build_upload_gcs("my_folder")
```

Putting the above together:

```r
cr_build(my_yaml, source = storage)
```

### R buildsteps

You can send in R code into a build trigger using `cr_buildstep_r()`.   It accepts both inline R code or a file location.  They default to the R images provided by Rocker [rocker-project.org](https://www.rocker-project.org/) or if you create your own R images you can reference those. 

The R code can be created within the Build at build time, or you can refer to an existing R script within the Source.

```r
# create an R buildstep inline
cr_buildstep_r(c("paste('1+1=', 1+1)", "sessionInfo()"))

# create an R buildstep from a local file
cr_buildstep_r("my-r-file.R")

# create an R buildstep from a file within the source of the Build
cr_buildstep_r("inst/schedule/schedule.R", r_source = "runtime")

# use a different Rocker image e.g. rocker/verse
cr_buildstep_r(c("library(dplyr)", "mtcars %>% select(mpg)", "sessionInfo"),
                name = "verse")

# use your own R image with custom R
my_r <- c("devtools::install()", "pkgdown::build_site()")
br <-  cr_buildstep_r(my_r, name= "gcr.io/gcer-public/packagetools:master")

# send it for building
cr_build(Yaml(steps=br))

```


## Build Triggers

Once you have build steps and possibly a source created, you can either set these up to run on a schedule via `cr_schedule()` or you can use triggers that will run upon certain events.  These include GitHub commits and pull requests.  These Build Triggers can be setup in the webUI or programatically from R via the `cr_buildtrigger*` functions.

To work with GitHub events, configure GitHub to use the offical [Google Cloud Build app](https://github.com/marketplace/google-cloud-build) and then construct your GitHub triggers using `GitHubEventsConfig()`.

The example below shows how to set up some of the builds above:

```r
cloudbuild <- system.file("cloudbuild/cloudbuild.yaml",
                            package = "googleCloudRunner")
bb <- cr_build_make(cloudbuild, projectId = "test-project")
github <- GitHubEventsConfig("MarkEdmondson1234/googleCloudRunner", branch = "master")

cr_buildtrigger("trig1", trigger = github, build = bb)
```

The Build macros can also be configured by passing in a named list:

```r
# creates a trigger with named substitutions
ss <- list(`$_MYVAR` = "TEST1", `$_GITHUB` = "MarkEdmondson1234/googleCloudRunner")
cr_buildtrigger("trig2", trigger = github, build = bb, substitutions = ss)
```

The above examples created the build step inline within the trigger, but you can use existing cloudbuild.yaml files by specifying where in the repository the build file will be:

```r
# create a trigger that will build from the file in the repo
cr_buildtrigger("trig3", trigger = github, build = "inst/cloudbuild/cloudbuild.yaml")
```

